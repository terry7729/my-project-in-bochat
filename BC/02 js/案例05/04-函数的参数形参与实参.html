<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>
        /*
        * function 函数名(形参) {
        *   函数体代码;
        * }
        * 声明中的参数,是形式参数
        *
        * 函数名(实参);
        * 调用中的参数,是实际参数
        * */

        //function demo1(a,b) {
        //    //a与b其实也是变量,声明函数的同时,就同时声明了这两个参数的变量
        //    console.log("这是a还没有改变之前的值:"+a);
        //    console.log("这是b还没有改变之前的值:"+b);
        //    a = 100;
        //    b = 200;
        //    console.log("这是改变之后的a"+a);
        //    console.log("这是改变之后的b"+b);
        //    //在函数内改变形参,请问,对函数外的实参有没有影响
        //}
        //你没有调用,函数的声明,就像一个安静的美男子,不会调用自己的

        //demo1();
        //函数名()====调用函数

        //var num1 = 10,num2 = 20;
        //demo1(num1,num2);
        ////调用函数小括号中的参数,实际参数
        ////传参的过程中,会按照实参顺序赋值给形参
        //console.log(num1, num2);//还活着
        ////形参的修改,对实参没有影响,他们的赋值过程是值引用,直接把值复制过去

        //console.log(a, b);//报错:没有声明,直接使用,已经死了

        //当函数调用结束,形参就已经被内存销毁了,死了


        //讨论形参与实参的数目问题
        function demo2(a,b) {
            console.log(a, b);
        }
        demo2(10);//不会报错

        demo2(10,20,30);//不会报错

        //实参与形参的数目对不上,是不会报错的


        //1.函数在声明的同时,也声明了形参变量
        //2.函数传参的顺序按照实参的顺序来赋值的
        //3.形参的修改,对实参是没有影响的(在这个demo中)
        //4.形参只能在函数中存活,函数调用结束,内存就被销毁
        //5.实参与形参的数目对不上,是不会报错的

    </script>
</head>
<body>

</body>
</html>